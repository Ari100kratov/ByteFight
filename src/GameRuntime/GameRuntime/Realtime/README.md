# Realtime Game Runtime — текущая архитектура и планы развития

## Контекст проблемы

GameRuntime исполняет игровую сессию асинхронно и независимо от клиента.
Ходы (TurnLog) генерируются сервером с фиксированным интервалом и отправляются на фронт через SignalR.

Проблема, с которой я столкнулся:

- SignalR **не гарантирует**, что клиент уже подключён к хабу или группе
- первые тики могут быть отправлены **до того, как фронт успел подключиться**
- `Clients.Group(...).SendAsync()`:
  - не падает, если группа пуста
  - не даёт информации о доставке
- в результате **первые ходы теряются**

Важно:
- GameInstance **не должен блокироваться**, ожидая фронт
- последовательность ходов **должна сохраняться**
- решение должно быть **простым**, т.к. это промежуточный этап

---

## Текущее архитектурное решение (MVP)

### Ключевая идея

Сервер **явно знает**, есть ли хотя бы один клиент, подключённый к игровой сессии,
и **буферизует ходы**, пока клиентов нет.

Когда клиент появляется:
- все накопленные ходы отправляются **в правильном порядке**
- далее ходы идут в realtime

---

## Основные компоненты

### 1. GameSessionRealtimeRegistry

In-memory реестр состояния realtime-сессий:

- хранит количество подключённых клиентов
- хранит очередь `PendingLogs` (буфер тиков)
- живёт **только в памяти процесса**

```text
GameSessionId
 ├─ ConnectedClients
 └─ PendingLogs (FIFO)
````

Используется как единая точка истины:

> «Можно ли сейчас отправлять события в SignalR или нужно буферизовать?»

---

### 2. GameRuntimeHub

Hub **явно сообщает** о жизненном цикле подключения клиента:

* `JoinGame`:

  * добавляет connection в SignalR group
  * увеличивает счётчик клиентов в registry
* `LeaveGame`:

  * уменьшает счётчик клиентов

Это принципиально важно:

> мы **не пытаемся угадать** состояние по SendAsync —
> мы знаем его из Hub-событий.

---

### 3. GameRuntimeHubEventSender

EventSender отвечает за **гарантированный порядок отправки**:

* если клиентов нет → `TurnLog` кладётся в `PendingLogs`
* если клиент есть:

  1. сначала отправляются все накопленные логи
  2. затем текущий тик
* при `SendFinished`:

  * состояние сессии удаляется
  * буфер очищается

Таким образом:

* первый тик не теряется
* порядок строго сохраняется

---

## Как это должно выглядеть в будущем (следующий этап)

После того как **логи игровой сессии будут храниться в БД**, архитектура должна измениться.

### Новая точка истины

**Не SignalR и не in-memory буфер**, а база данных:

* каждый `TurnLog` сохраняется с `TurnIndex`
* сервер всегда может восстановить историю

---

### Будущая модель взаимодействия

1. Клиент подключается к хабу и вызывает:

   ```text
   JoinGame(sessionId, lastSeenTurnIndex)
   ```

2. Сервер:

   * читает из БД все `TurnLog` с `TurnIndex > lastSeenTurnIndex`
   * отправляет их клиенту **в правильном порядке**

3. Далее клиент получает realtime-тики как обычно

---

### Что это даст

* корректные реконнекты
* поддержка обновления страницы
* несколько клиентов / зрителей
* масштабирование
* отсутствие in-memory буферов

---